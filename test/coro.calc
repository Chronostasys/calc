package main

import (
    "github.com/Chronostasys/calc/runtime/generator"
    "github.com/Chronostasys/calc/runtime/coro"
    "github.com/Chronostasys/calc/runtime/libuv"
    "github.com/Chronostasys/calc/runtime"
)


func testCoroutine() void {
    libuv.StartUVLoop()
    testCoroutineAsync()
    coro.Exec()

    libuv.TCPListen("0.0.0.0",8888,func (server libuv.UVTcp, status int32) void {
        s := "new tcp conn"
        s.PrintLn()
        jeff := func () coro.Task<int> async {
            for {
                buf := await server.ReadBufAsync(10)
                ss := runtime.newstr(buf.Data,buf.Len)
                ss.Print()
                re := await server.WriteBufAsync("got it!\n")
                if re !=0 {
                    sss := "write failed"
                    sss.PrintLn()
                    printIntln(re)
                }
            }
            return 0
        }
        jeff()
        return
    })
    coro.Run<int>(func () int {
        Sleep(2000)
        s := "run task awake after 2s"
        s.PrintLn()
        return 0
    })
    for i :=0; i<50 ; i = i + 1 {
        testCoroutineAsync()
    }
    coroutine2()
    Sleep(3000000)
    return
}

func testCoroutineAsync() coro.Task<int> async {
    s := "async func main queued"
    s.PrintLn()
    s = "async func main call async func 1"
    s.PrintLn()
    re := await coroutine1()
    s = "async func 1 return in async func main:"
    s.PrintLn()
    printIntln(re)

    return 1
}

func coroutine1() coro.Task<int> async {
    t := libuv.NewTimer()
    await t.Delay(1000)
    return 8989
}

func coroutine2() coro.Task<int> async {
    s := "async func 2 queued"
    s.PrintLn()
    s = "async func 2 call async func 1"
    s.PrintLn()
    c1 :=  coroutine1()
    // block current thread 1.5s, ensure the task is complete when await
    Sleep(1500)
    re := await c1
    s = "async func 1 return in async func 2:"
    s.PrintLn()
    printIntln(re)
    
    return 2
}
