package coro

import (
    "github.com/Chronostasys/calc/runtime/linkedlist"
    "github.com/Chronostasys/calc/runtime/coro/sync"
    "github.com/Chronostasys/calc/runtime/coro/thread"
)

var sch = NewScheduler()

type StateMachine interface {
    StepNext() bool
}

type defaultScheduler struct {
    tasks *linkedlist.List<StateMachine>
    mu  sync.Locker
}

type Scheduler interface {
    QueueTask(s StateMachine) void
    Exec() void
    Len() int
}


func NewScheduler() Scheduler {
    mu := sync.NewMutex()
    return &defaultScheduler{
        tasks: linkedlist.New<StateMachine>(),
        mu: mu,
    }
}

func QueueTask(this s *defaultScheduler, st StateMachine) void {
    s.mu.Lock()
    s.tasks.Push(st)
    s.mu.UnLock()
    return
}

func QueueTaskIfPossible(st *StateMachine) void {
    if st == nil {
        return
    }
    sch.QueueTask(*st)
    return
}

func QueueTask(st StateMachine) void {
    sch.QueueTask(st)
    return
}
func Exec() void {
    sch.Exec()
    return
}


func Exec(this ds *defaultScheduler) void {
    job := func (arg *byte) *byte {
        id := unsafecast<*byte,*int>(arg)
        s := "thread start"
        s.PrintLn()
        printIntln(*id)
        for  {
            ds.mu.Lock()
            if ds.tasks.Len()==0 {
                ds.mu.UnLock()
                Sleep(100)
                continue
            }
            t := ds.tasks.Shift()
            ds.mu.UnLock()
            for ;t.StepNext(); {
            }
        }
        return nil
    }
    for i := 0;i<8;i=i+1 {
        t := 0
        thid := i
        th := thread.GC_pthread_create(&t,nil,job,unsafecast<*int,*byte>(&thid))
    }
    Sleep(3000)
    return
}

func Len(this s *defaultScheduler) int {
    l := s.tasks.Len()
    return l
}


