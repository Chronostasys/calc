package coro

import (
    "github.com/Chronostasys/calc/runtime/generator"
    "github.com/Chronostasys/calc/runtime/linkedlist"
    "github.com/Chronostasys/calc/runtime/coro/sync"
    "github.com/Chronostasys/calc/runtime/coro/thread"
    "github.com/Chronostasys/calc/runtime/coro/sm"
)

var sch = NewScheduler()

type AsyncGen struct {
    nextTask int
    f func() void
}

func StepNext(this ag *AsyncGen) bool {
    ag.f()
    return false
}
func GetCurrent(this ag *AsyncGen) void {
    return
}

type defaultScheduler struct {
    tasks *linkedlist.List<sm.StateMachine>
    mu  *sync.Mutex
    cond *sync.Cond
}

type Scheduler interface {
    QueueTask(s sm.StateMachine) void
    Exec() void
    Len() int
}

func Run(job func () void) generator.Generator<void> {
    ag := &AsyncGen{}
    ag.f = func () void {
        job()
        state := inttoptr<*sm.StateMachine>(ag.nextTask)
        QueueTaskIfPossible(state)
        return
    }
    return ag
}


func NewScheduler() Scheduler {
    mu := sync.NewMutex()
    cond := sync.NewCond()
    return &defaultScheduler{
        tasks: linkedlist.New<sm.StateMachine>(),
        mu: mu,
        cond: cond,
    }
}

func QueueTask(this s *defaultScheduler, st sm.StateMachine) void {
    s.mu.Lock()
    s.tasks.Push(st)
    s.cond.Signal()
    s.mu.UnLock()
    return
}

func QueueTaskIfPossible(st *sm.StateMachine) void {
    if st == nil {
        return
    }
    sch.QueueTask(*st)
    return
}

func QueueTask(st sm.StateMachine) void {
    sch.QueueTask(st)
    return
}
func Exec() void {
    sch.Exec()
    return
}


func Exec(this ds *defaultScheduler) void {
    job := func (id *int) *byte {
        s := "thread start"
        s.PrintLn()
        printIntln(*id)
        for  {
            ds.mu.Lock()
            for ;ds.tasks.Len()==0; {
                ds.cond.Wait(ds.mu)
            }
            t := ds.tasks.Shift()
            ds.mu.UnLock()
            for ;t.StepNext(); {
            }
        }
        return nil
    }
    for i := 0;i<8;i=i+1 {
        t := 0
        thid := i
        th := thread.New<*int,*byte>(job,&thid)
    }
    return
}

func Len(this s *defaultScheduler) int {
    l := s.tasks.Len()
    return l
}


