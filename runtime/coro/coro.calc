package coro

import (
    "github.com/Chronostasys/calc/runtime/linkedlist"
    "github.com/Chronostasys/calc/runtime/coro/sync"
    "github.com/Chronostasys/calc/runtime/coro/thread"
)

var sch = NewScheduler()

type StateMachine interface {
    StepNext() bool
}

type defaultScheduler struct {
    tasks *linkedlist.List<StateMachine>
    mu  sync.Locker
}

type Scheduler interface {
    QueueTask(s StateMachine) void
    Exec() void
    Len() int
}


func NewScheduler() Scheduler {
    mu := sync.NewMutex()
    return &defaultScheduler{
        tasks: linkedlist.New<StateMachine>(),
        mu: mu,
    }
}

func QueueTask(this s *defaultScheduler, st StateMachine) void {
    s.mu.Lock()
    s.tasks.Push(st)
    s.mu.UnLock()
    return
}

func QueueTaskIfPossible(st *StateMachine) void {
    if st == nil {
        return
    }
    sch.QueueTask(*st)
    return
}

func QueueTask(st StateMachine) void {
    sch.QueueTask(st)
    return
}
func Exec() void {
    sch.Exec()
    return
}


func Exec(this ds *defaultScheduler) void {
    job := func (arg *byte) *byte {
        s := "thread start"
        s.PrintLn()
        for  {
            if ds.tasks.Len()==0 {

                break
            }
            t := ds.tasks.Shift()

            for ;t.StepNext(); {
            }
        }
        return nil
    }
    t := 0
    th := thread.pthread_create(&t,nil,job,nil)
    return
}

func Len(this s *defaultScheduler) int {
    l := s.tasks.Len()
    return l
}


