# 使用libuv进行异步io封装
默认使用一个事件循环运行linuv的loop。  
由于loop相关的操作并非线程安全，所以我们需要在loop里跑一个定时触发的timer，
每过一点时间就扫描一个线程安全的队列，将其中的所有任务取出并注册到事件循环中。  
而别的线程执行异步io操作的时候，实际上是将一个闭包函数加入这个线程安全队列。

## libuv && bdwgc
所有的libuv的handle都是用`GC_malloc`分配的内存，但是使用一些异步io操作的时候，可能libuv并不会保留
对这些handle对象的引用，导致资源被过早的被gc。例如`uv_tcp_connect`，如果使用了ioc是不会保留对输入的conn handle的引用的。因此封装的时候务必多测试，并且通过手动添加引用确保对象的生命周期是正常的。

