{
	"patterns": [
		{
			"include": "#receiver_function_declaration"
		},
		{
			"include": "#plain_function_declaration"
		},
		{
			"include": "#type_declaration"
		},
		{
			"include": "#basic_things"
		},
		{
			"include": "#exported_variables"
		},
		{
			"begin": "^\\s*(import)\\b\\s+",
			"beginCaptures": {
				"1": {
					"name": "keyword.control.import.go"
				}
			},
			"end": "(?=(?://|/\\*))|$",
			"name": "meta.preprocessor.go.import",
			"patterns": [
				{
					"begin": "\"",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.go"
						}
					},
					"end": "\"",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.go"
						}
					},
					"name": "string.quoted.double.import.go"
				}
			]
		},
		{
			"include": "#block"
		},
		{
			"include": "#root_parens"
		},
		{
			"include": "#function_calls"
		}
	],
	"repository": {
		"access": {
			"match": "(?<=\\.)[[:alpha:]_]\\w*\\b(?!\\s*\\()",
			"name": "variable.other.dot-access.go"
		},
		"basic_things": {
			"patterns": [
				{
					"include": "#comments"
				},
				{
					"include": "#initializers"
				},
				{
					"include": "#access"
				},
				{
					"include": "#strings"
				},
				{
					"include": "#keywords"
				}
			]
		},
		"block": {
			"begin": "\\{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.block.begin.go"
				}
			},
			"end": "\\}",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.block.end.go"
				}
			},
			"name": "meta.block.go",
			"patterns": [
				{
					"include": "#block_innards"
				}
			]
		},
		"block_innards": {
			"patterns": [
				{
					"include": "#function_block_innards"
				},
				{
					"include": "#exported_variables"
				}
			]
		},
		"comments": {
			"patterns": [
				{
					"captures": {
						"1": {
							"name": "meta.toc-list.banner.block.go"
						}
					},
					"match": "^/\\* =(\\s*.*?)\\s*= \\*/$\\n?",
					"name": "comment.block.go"
				},
				{
					"begin": "/\\*",
					"captures": {
						"0": {
							"name": "punctuation.definition.comment.go"
						}
					},
					"end": "\\*/",
					"name": "comment.block.go"
				},
				{
					"match": "\\*/.*\\n",
					"name": "invalid.illegal.stray-comment-end.go"
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.definition.comment.go"
						},
						"2": {
							"name": "meta.toc-list.banner.line.go"
						}
					},
					"match": "^(//) =(\\s*.*?)\\s*=\\s*$\\n?",
					"name": "comment.line.double-slash.banner.go"
				},
				{
					"begin": "(^[ \\t]+)?(?=//)",
					"beginCaptures": {
						"1": {
							"name": "punctuation.whitespace.comment.leading.go"
						}
					},
					"end": "(?!\\G)",
					"patterns": [
						{
							"begin": "//",
							"beginCaptures": {
								"0": {
									"name": "punctuation.definition.comment.go"
								}
							},
							"end": "\\n",
							"name": "comment.line.double-slash.go",
							"patterns": [
								{
									"match": "(?>\\\\\\s*\\n)",
									"name": "punctuation.separator.continuation.go"
								}
							]
						}
					]
				}
			]
		},
		"exported_variables": {
			"comment": "This is kinda hacky, in order to get the 'var' scoped the right way again.",
			"match": "(?<=\\s|\\[\\])([[:upper:]]\\w*)(?=\\W+)",
			"name": "variable.other.exported.go"
		},
		"fn_parens": {
			"begin": "\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.parens.begin.go"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.parens.end.go"
				}
			},
			"name": "meta.parens.go",
			"patterns": [
				{
					"include": "#basic_things"
				},
				{
					"include": "#function_calls"
				}
			]
		},
		"function_block": {
			"begin": "\\{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.function-block.begin.go"
				}
			},
			"end": "\\}",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.function-block.end.go"
				}
			},
			"name": "meta.block.go",
			"patterns": [
				{
					"include": "#function_block_innards"
				}
			]
		},
		"function_block_innards": {
			"patterns": [
				{
					"include": "#basic_things"
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.whitespace.support.function.leading.go"
						},
						"2": {
							"name": "support.function.builtin.go"
						}
					},
					"match": "(\\s*)\\b(new|c(lose|ap)|p(anic|rint(ln)?)|len|make|append)(?:\\b|\\()"
				},
				{
					"include": "#function_block"
				},
				{
					"include": "#function_calls"
				},
				{
					"include": "#fn_parens"
				}
			]
		},
		"function_calls": {
			"captures": {
				"1": {
					"name": "punctuation.whitespace.function-call.leading.go"
				},
				"2": {
					"name": "support.function.any-method.go"
				},
				"3": {
					"name": "punctuation.definition.parameters.go"
				}
			},
			"match": "(?x)\r\n\t\t\t    (?: (?= \\s ) (?:(?<=else|new|return) | (?<!\\w)) (\\s+) )?\r\n\t\t\t    (\\b\r\n\t\t\t        (?!(for|if|else|switch|return)\\s*\\()\r\n\t\t\t        (?:[[:alpha:]_]\\w*+\\b)            # method name\r\n\t\t\t    )\r\n\t\t\t    \\s*(\\()\r\n\t\t\t",
			"name": "meta.function-call.go"
		},
		"initializers": {
			"patterns": [
				{
					"captures": {
						"1": {
							"name": "keyword.control.go"
						},
						"2": {
							"patterns": [
								{
									"match": "[[:alpha:]_]\\w*",
									"name": "variable.other.go"
								}
							]
						},
						"3": {
							"patterns": [
								{
									"include": "#keywords"
								},
								{
									"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
									"name": "support.type.go"
								}
							]
						}
					},
					"comment": "This matches the 'var x' style of variable declaration.",
					"match": "^\\s*(var)\\s+((?:[[:alpha:]_]\\w*)(?:,\\s+[[:alpha:]_]\\w*)*)\\s*(.*?)\\s*(?:=|$)",
					"name": "meta.initialization.explicit.go"
				},
				{
					"captures": {
						"1": {
							"patterns": [
								{
									"match": "[[:alpha:]_]\\w*",
									"name": "variable.other.go"
								}
							]
						},
						"2": {
							"name": "keyword.operator.go"
						},
						"3": {
							"patterns": [
								{
									"include": "#keywords"
								},
								{
									"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
									"name": "support.type.go"
								}
							]
						}
					},
					"comment": "This matches the 'x :=' style of variable declaration.",
					"match": "((?:[[:alpha:]_]\\w*)(?:\\s*,\\s+[[:alpha:]_]\\w*)*)\\s*(:=)(?:\\s*([[:alpha:]_]\\w*)\\s*\\{)?",
					"name": "meta.initialization.short.go"
				}
			]
		},
		"keywords": {
			"patterns": [
				{
					"match": "\\b(s(elect|witch)|c(ontinue|ase)|type|i(nterface|f|mport)|def(er|ault)|package|else|var|f(or|unc|allthrough)|r(eturn|ange)|go(to)?|break)\\b",
					"name": "keyword.control.go"
				},
				{
					"match": "(\\b|(?<=\\]))(int(16|8|32|64)?|uint(16|8|32|64|ptr)?|rune|float(32|64)|complex(64|128)|b(yte|ool)|string|error|struct)\\b",
					"name": "storage.type.go"
				},
				{
					"match": "\\b(c(onst|han)|map)\\b",
					"name": "storage.modifier.go"
				},
				{
					"match": "\\b(nil|true|false|iota)\\b",
					"name": "constant.language.go"
				},
				{
					"match": "\\b((0(x|X)[0-9a-fA-F]*)|((\\d+\\.?\\d*)|(\\.\\d+))((e|E)(\\+|-)?\\d+)?)\\b",
					"name": "constant.numeric.go"
				},
				{
					"match": "\\<\\-",
					"name": "keyword.operator.channel.go"
				}
			]
		},
		"plain_function_declaration": {
			"begin": "(?x)\r\n\t\t\t        (^\\s*(func)\\s*\r\n\t\t\t         ([[:alpha:]_]\\w*)?                                            # name of function is optional\r\n\t\t\t         \\( ((?:[\\[\\]\\w\\d\\s\\/,._*&<>-]|(?:interface\\{\\}))*)? \\)        # required braces for parameters (even if empty)\r\n\t\t\t         \\s*\r\n\t\t\t         (?:                                                           # optional return types\r\n\t\t\t          (?: \\( ((?:[\\[\\]\\w\\d\\s,._*&<>-]|(?:interface\\{\\}))*) \\) ) |  # within braces\r\n\t\t\t          (?: ((?:[\\[\\]\\w\\d\\s,._*&<>-]|(?:interface\\{\\}))*) )          # without braces (just type)\r\n\t\t\t         )?\r\n\t\t\t        )\r\n\t\t\t",
			"beginCaptures": {
				"1": {
					"name": "meta.function.declaration.go"
				},
				"2": {
					"name": "keyword.control.go"
				},
				"3": {
					"name": "entity.name.function.go"
				},
				"4": {
					"patterns": [
						{
							"captures": {
								"1": {
									"name": "variable.parameter.go"
								}
							},
							"match": "(?<=[\\(,])\\s*([[:alpha:]_]\\w*)"
						},
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
							"name": "support.type.parameter.go"
						}
					]
				},
				"5": {
					"patterns": [
						{
							"captures": {
								"1": {
									"name": "variable.parameter.return.go"
								}
							},
							"match": "(?<=[\\(,])\\s*([[:alpha:]_]\\w*)"
						},
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
							"name": "support.type.return.go"
						}
					]
				},
				"6": {
					"patterns": [
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
							"name": "support.type.return.go"
						}
					]
				}
			},
			"comment": "We scope all parenthesized alpha-numeric text as variable.parameter.go and storage.type.return.go, which is a bit lazy, as some of it is storage.type.",
			"end": "(?<=\\})",
			"name": "meta.function.plain.go",
			"patterns": [
				{
					"include": "#comments"
				},
				{
					"include": "#keywords"
				},
				{
					"include": "#function_block"
				}
			]
		},
		"receiver_function_declaration": {
			"begin": "(?x)\r\n\t\t\t        (\r\n\t\t\t         (func)\\s*\r\n\t\t\t         (\r\n\t\t\t         \\( ((?:[\\[\\]\\w\\d\\s,._*&<>-]|(?:interface\\{\\}))*) \\)\\s+        # receiver variable declarations, in brackets\r\n\t\t\t         ([[:alpha:]_]\\w*)?                                            # name of function is optional\r\n\t\t\t         )\r\n\t\t\t         \\( ((?:[\\[\\]\\w\\d\\s,._*&<>-]|(?:interface\\{\\}))*)? \\)          # required braces for parameters (even if empty)\r\n\t\t\t         \\s*\r\n\t\t\t         (?:                                                           # optional return types\r\n\t\t\t          (?: \\( ((?:[\\[\\]\\w\\d\\s,._*&<>-]|(?:interface\\{\\}))*) \\) ) |  # within braces\r\n\t\t\t          (?: ((?:[\\[\\]\\w\\d\\s,._*&<>-]|(?:interface\\{\\}))*) )          # without braces (just type)\r\n\t\t\t         )?\r\n\t\t\t        )\r\n\t\t\t",
			"beginCaptures": {
				"1": {
					"name": "meta.function.receiver.declaration.go"
				},
				"2": {
					"name": "keyword.control.go"
				},
				"3": {
					"name": "entity.name.function.full-name.go"
				},
				"4": {
					"patterns": [
						{
							"captures": {
								"1": {
									"name": "variable.other.receiver.go"
								}
							},
							"match": "(?<=[\\(,])\\s*([[:alpha:]_]\\w*)"
						},
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*",
							"name": "support.type.receiver.go"
						}
					]
				},
				"5": {
					"name": "entity.name.function.go"
				},
				"6": {
					"patterns": [
						{
							"captures": {
								"1": {
									"name": "variable.parameter.go"
								}
							},
							"match": "(?<=[\\(,])\\s*([[:alpha:]_]\\w*)"
						},
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
							"name": "support.type.parameter.go"
						}
					]
				},
				"7": {
					"patterns": [
						{
							"captures": {
								"1": {
									"name": "variable.parameter.return.go"
								}
							},
							"match": "(?<=[\\(,])\\s*([[:alpha:]_]\\w*)"
						},
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
							"name": "support.type.return.go"
						}
					]
				},
				"8": {
					"patterns": [
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
							"name": "support.type.return.go"
						}
					]
				}
			},
			"comment": "Version of above with support for declaring a receiver variable.",
			"end": "(?<=\\})",
			"name": "meta.function.receiver.go",
			"patterns": [
				{
					"include": "#comments"
				},
				{
					"include": "#keywords"
				},
				{
					"include": "#function_block"
				}
			]
		},
		"root_parens": {
			"begin": "\\(",
			"end": "(?<=\\()(\\))?|(?:\\))",
			"endCaptures": {
				"1": {
					"name": "meta.parens.empty.go"
				}
			},
			"name": "meta.parens.go",
			"patterns": [
				{
					"include": "#basic_things"
				},
				{
					"include": "#exported_variables"
				},
				{
					"include": "#function_calls"
				}
			]
		},
		"string_escaped_char": {
			"patterns": [
				{
					"match": "\\\\(\\\\|[abfnrutv'\"]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8}|[0-7]{3})",
					"name": "constant.character.escape.go"
				},
				{
					"match": "\\\\.",
					"name": "invalid.illegal.unknown-escape.go"
				}
			]
		},
		"string_placeholder": {
			"patterns": [
				{
					"match": "(?x)%\r\n\t\t\t\t\t    (\\d+\\$)?                                 # field (argument #)\r\n\t\t\t\t\t    [#0\\- +']*                              # flags\r\n\t\t\t\t\t    [,;:_]?                                  # separator character (AltiVec)\r\n\t\t\t\t\t    ((-?\\d+)|\\*(-?\\d+\\$)?)?                  # minimum field width\r\n\t\t\t\t\t    (\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?             # precision\r\n\t\t\t\t\t    (\\[\\d+\\])?                               # argument index\r\n\t\t\t\t\t    [diouxXDOUeEfFgGaAcCsSpnvtTbyYhHmMzZq%]  # conversion type\r\n\t\t\t\t\t",
					"name": "constant.other.placeholder.go"
				},
				{
					"match": "%",
					"name": "invalid.illegal.placeholder.go"
				}
			]
		},
		"strings": {
			"patterns": [
				{
					"begin": "\"",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.go"
						}
					},
					"end": "\"",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.go"
						}
					},
					"name": "string.quoted.double.go",
					"patterns": [
						{
							"include": "#string_placeholder"
						},
						{
							"include": "#string_escaped_char"
						}
					]
				},
				{
					"begin": "'",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.go"
						}
					},
					"end": "'",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.go"
						}
					},
					"name": "string.quoted.single.go",
					"patterns": [
						{
							"include": "#string_escaped_char"
						}
					]
				},
				{
					"begin": "`",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.go"
						}
					},
					"end": "`",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.go"
						}
					},
					"name": "string.other.raw.go"
				}
			]
		},
		"type_declaration": {
			"captures": {
				"1": {
					"name": "keyword.control.go"
				},
				"2": {
					"name": "entity.name.type.exported.go"
				},
				"3": {
					"name": "entity.name.type.private.go"
				},
				"4": {
					"patterns": [
						{
							"include": "#keywords"
						},
						{
							"match": "[[:alpha:]_]\\w*\\b(?!\\.)",
							"name": "support.type.go"
						}
					]
				}
			},
			"match": "(?x)\r\n\t\t\t         ^\\s*(type)\\s*\r\n\t\t\t          (?:([[:upper:]]\\w*)|([[:alpha:]_]\\w*))           # name of type\r\n\t\t\t          ((?:[\\[\\]\\w\\d\\s\\/,._*&<>-]|(?:interface\\{\\}))*)? # other type\r\n\t\t\t",
			"name": "meta.type.go"
		}
	},
	"scopeName": "source.calc"
}