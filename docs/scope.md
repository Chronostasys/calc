# Scope
在遍历Ast的时候，我们使用scope来表示作用域。  
每个scope会记录自己的上一层scope和本层的符号表，这样在编译的时候
查找变量时从本scope开始一层一层往上查找，直到查到最上层的scope。  

## Scope与模块化

现阶段只有一个globalScope，对应全局作用域，里边会包含全局定义的变量、函数类型和接口。  
目前的编译器只能编译一个源文件，首先我们考虑编译同一模块多个源文件的情况：  
先假设不适用外界的模块，那么可以把它们直接合并为一个源文件编译，用一个globalscope。这是十分简单且自然的。  
但是，一旦能够import情况就会变得复杂：不同的文件import相同的package可能会起不一样的别名（和golang一样，默认的别名是package的最后一段），也有可能不同文件中相同别名指的是不同的东西。为了确保不出现这种情况，采用下方解决方法（`替换-合并法`）：  
- 在扫描文件源码生成ast的一开始就记录好别名和全名的对应关系，之后生成具有名字的ast节点的时候直接替换别名为全名。
- 先把本模块所有源码文件全部按照上方方法扫描完，生成文件数量个ast，然后将它们合并（因为第一步使得具名节点都是全名了，所以这一步很简单）
- 合并完成之后我们就获得了本模块的完整ast

接下来是生成本模块的中间代码（ir）：  
- 扫描合并后的import node，找到import的包的源码地址，使用`替换-合并`法生成它们的ast
- 对它们每一个分别执行生成中间代码算法
- 递归直到结束

每个模块的ast都存在全局的一个hashmap中，key为模块全名，值为ast  
在查找符号表找不到变量名时，将变量名当作模块名在全局哈希表中查找，然后用下一个变量block在该模块的globalscope中查找变量

